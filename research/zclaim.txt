arXiv:2204.10611v1 [cs.CR] 22 Apr 2022

Bridging Sapling: Private Cross-Chain Transfers
Aleixo Sanchez∗†
aleixo@web3.foundation

Alistair Stewart†
stewart.al@gmail.com

Fatemeh Shirazi‡
fatemeh@heliax.dev

∗ ETH Zürich

† Web3 Foundation

‡ Heliax

Zürich, Switzerland

Zug, Switzerland

Zug, Switzerland

Abstract—Interoperability is one of the main challenges of
blockchain technologies, which are generally designed as selfcontained systems. Interoperability schemes for privacy-focused
blockchains are particularly hard to design: they must integrate
with the unique privacy features of the underlying blockchain
so as to prove statements about specific transactions in protocols
designed to obfuscate them. This has led to users being forced
to weaken their privacy, e.g. by using centralised exchanges, to
move assets from one chain to another. We present Z CLAIM,
a framework for trustless cross-chain asset migration based on
the Zcash privacy-protecting protocol. Z CLAIM integrates with
an implementation of the Sapling version of Zcash on a smartcontract capable issuing chain in order to attain private crosschain transfers. We show that a tokenised representation can be
created via a set of collateralised intermediaries without relying
on or revealing the total amount to any third party.
Index Terms—Privacy, Cross-Chain, Interoperability, Noninteractive Zero-Knowledge Proof, Blockchain

I. I NTRODUCTION
Since the creation of Bitcoin in 2009, thousands of cryptocurrencies and blockchains with a wide array of applications
have emerged. This fragmentation of the blockchain space has
created a market for interoperability solutions [1], [2], which
we loosely define here as the ability to verify a transaction
in a network other than the one in which it was created.
Unfortunately, the vast majority of blockchains are siloed,
not having been designed with interoperability in mind. This
results in significant complexity required to design cross-chain
protocols; hence, this challenge has until recently mostly been
circumvented through the use of centralised exchanges. These
require trust and undermine anonymity, which is particularly
undesirable in the case of privacy-oriented cryptocurrencies
designed around the notion of payment anonymity. Despite a
mounting interest in recent years in the deployment of privacy
features in blockchain protocols, in particular of various zeroknowledge proof primitives [3], little attention has been given
to maintaining the privacy achieved in this manner across
chains. That means users must reveal, or at least risk revealing,
their identity if they wish to move assets from one privacypreserving system to another. This acts as a major limitation
in the usability of these systems, as one can only durably
rely on the privacy guarantees of a given system by remaining
confined to it.

To address this, in this work we introduce Z CLAIM1 , a
protocol enabling private transactions across chains. This is
to the authors’ knowledge the first scheme that succeeds
in maintaining privacy in cross-chain transfers. Our protocol
follows the structure of X CLAIM [5], a framework achieving
collateralised trustless asset migration by leveraging smart
contract logic, a dynamic set of economically incentivised,
trustless intermediaries and cross-chain state verification. This
approach to interoperability falls under what is colloquially
referred to as the “wrapping” of assets.
Z CLAIM builds upon said framework by integrating with the
Zcash [6] protocol in such a way as to maintain anonymity. On
the chain on which the wrapped assets are issued, the issuing
chain, we assume an implementation of Sapling according to
its specification [6] and introduce new transfer types, with
accompanying zk-SNARKs [7], to facilitate interoperability.
These transfers integrate with Zcash’s private or shielded
payment scheme and enable the issuing and redeeming of
value. Furthermore, we discuss the custom logic necessary
to carry out the issue and redeem protocols, and present
and analyse a strategy to hide the transferred amount from
intermediaries.
The end result is a protocol enabling trustless cross-chain
transfers with similar privacy guarantees to those of Zcash
itself, which is considered to provide some of the strongest in
blockchain [3], [8].
The remainder of the paper is organized as follows. Section II studies related work and provides a brief summary
of concepts in the Zcash protocol. Section III introduces a
high-level description of the Z CLAIM protocol. Section IV
discusses risks and attacks, and Section V presents and analyses an approach to maintain privacy against intermediaries.
Section VI considers current limitations and future work and,
finally, Section VII concludes the paper.
II. BACKGROUND
A. Related Work
Atomic swaps [9], the traditional approach to decentralised
cross-chain exchanges, allow users on two blockchains to swap
ownership of a pre-agreed amount of assets, guaranteeing that
1 The Z CLAIM protocol is the contribution of a master’s thesis submitted
to ETH Zürich in collaboration with Web3 Foundation [4]. The thesis is
accessible under https://github.com/alxs/zclaim and contains a more
exhaustive and technical specification of the protocol.

the exchange either happens in full or not at all. Atomic swaps
present limitations such as 1) requiring the establishing of
an external communication channel to find and agree on a
swap, 2) an asymmetrical advantage for one out of the two
participants (“free option problem” [10]), and 3) relatively
long confirmation delays. There are ongoing efforts to implement atomic swaps between the privacy coin Monero [11]
and Bitcoin [12], [13] as well as Ethereum [14].
An alternative approach are asset migration protocols [15]
such as the one presented in this paper, in which a representation of an asset (its tokenised representation or “wrapped”
version) is created on a different chain, while those on the
original chain are locked until the process is reversed.
At least two different projects—Wrapped [16], a “provider
of wrapped layer-1 assets”, and the Ren Project, a generic
cross-chain transfer protocol [17]—offer tokenised representations of Zcash on Ethereum [18]. However, the former
relies on a centralised authority and neither of them supports
Zcash’s shielded payment scheme. The Zcash Foundation
announced [19] their intent to work on a “Zcash pegzone” [20]
for the Cosmos [21] ecosystem in 2020, with the goal of
enabling “shielded transfers from the pegzone to Zcash and
vice versa”; however, details on the project are scarce.
B. Zcash and Sapling
We now introduce basic concepts from Zcash used in this
work. For a formal definition of these concepts and the
cryptographic schemes employed in them, we refer the reader
to the Sapling version of the Zcash protocol specification [6].
Some terms have been simplified for ease of understanding.
Zcash is an implementation of the Zerocash [22], [23]
payment scheme. It builds on Bitcoin’s [24] transparent payment scheme, adding a private payment scheme leveraging
zk-SNARKs [7] to enable private payments. This work only
concerns itself with the latter.
Transactions in Sapling can contain transparent inputs,
outputs, and scripts, all of which work as in Bitcoin [24],
and shielded JoinSplit2 , Spend and Output transfers. Spend
and Output transfers are analogous to transparent inputs and
outputs, respectively. Each Spend transfer spends a note, and
each Output transfer creates one. A note represents that a value
v is spendable by the recipient who holds the private key
to the destination shielded payment address. A note’s sender,
recipient and value are never revealed.
All Spend and Output transfers in a transaction, along with
any transparent inputs and outputs, are checked to balance by
verifying that the sum of all value commitments and of all
transparent values is equal to zero.
To each note there is a cryptographically associated note
commitment, which is added to the note commitment tree when
the note is created. Only notes whose note commitment is
in the note commitment tree can be spent. When the note is
spent, a nullifier uniquely associated with that note must be
2 We ignore JoinSplit transfers, which Sapling only supports for backwards
compatibility.

revealed and is then added to the nullifier set. It is infeasible to
compute the nullifier without the spending key corresponding
to the recipient’s shielded payment address, and only notes
whose nullifier is not in the nullifier set can be spent.
The main premise of Zcash’s shielded payment scheme is
that when a note is spent, the spender only proves that its
note commitment is in the note commitment tree. Revealing
its nullifier also does not reveal which note commitment it
is associated with, which means that a spent note cannot be
linked to the transaction in which it was created.
The values required to spend a note are generally encrypted
to its recipient when it is created, though the protocol does not
enforce it. This has been a challenge in designing Z CLAIM,
since it is not enough to verify that a note exists in the note
commitment tree in order to verify a transaction. Instead, we
must also ensure that the counterparty receives these values.
III. Z CLAIM P ROTOCOL
We introduce Z CLAIM, an adaptation of X CLAIM to Zcash
so as to facilitate private transfers to any blockchain that
supports custom logic and efficient verification of the required
cryptographic functions [4, Section 5.2].
We define the following terms:
• ZEC denotes the Zcash cryptocurrency.
• wZEC denotes wrapped ZEC, the tokenised representation of ZEC on the issuing chain.
• I is the issuing chain, on which wZEC will be created.
• i is an implementation-defined existing currency on I.
A. Actors
The following actors participate in the protocol:
• Issuers lock ZEC on Zcash to request an equivalent
amount of wZEC on I.
• Redeemers destroy wZEC on I to request the corresponding amount of ZEC on Zcash.
• Vaults are the non-trusted intermediaries that act as
custodians, safekeeping locked ZEC. Anyone can take
on the role of a vault by locking some collateral in i and
registering as such. Vaults are liable for fulfilling redeem
requests of wZEC for ZEC. They are incentivised by fees
they derive from transactions and in case of misbehaviour,
they face partial or total liquidation of their collateral.
B. Components
The functionality that Z CLAIM requires on the issuing chain
can be split into the following components.
1) Vault registry: The vault registry keeps a public list of
all registered vaults and their status. Each vault has a Zcash
shielded payment address (d, pkd ) and an amount of collateral
associated with it. The collateral it keeps in i on the issuing
chain and thus the total amount of ZEC it is able to accept
are public; however, the amount of ZEC obligations to its
name, i.e. ZEC it participated in issuing and is accountable
for releasing, is not. It periodically proves that this amount
is properly backed by its collateral by submitting proofs of
balance, which consist of a zk-SNARK accounting for all
previous requests it has served.

2) Relay system: The relay system [25] keeps track of the
state of the Zcash chain. Specifically, it verifies and stores
block headers, provides a mechanism to signal that consensus
has been reached on a given block similarly to an SPV or
light client [26], [27], and allows the verification of Zcash
notes. Reaching consensus, in this context, requires fulfilling
implementation-specific criteria w.r.t. Zcash’s probabilistic finality; a possible approach is discussed in Section IV-B. In
order to prove the existence of a note, users must provide an
inclusion proof, which consists of a Merkle path from its note
commitment to the root of the note commitment tree in the
block header of a previous block. On the other hand, the relay
system does not need to offer functionality to verify whether
a nullifier already exists in the nullifier set.
Block headers are submitted to the relay system by relayers,
which may or may not be economically incentivised. Other
protocol actors are likely to take on the additional role of
relayers if the cost associated with doing so is low and it is in
their interest to guarantee the stability of the protocol. Vaults,
for example, are in such a position: they need to run full nodes
of both chains, and the financial damage they may incur from
an attack on the relay system as discussed in Section IV-B is
far greater than the cost of submitting headers.
3) Exchange rate oracle: The exchange rate oracle Oxr
provides an exchange rate that reflects the prevailing market
value of 1 ZEC in i. The design of the exchange rate oracle
falls outside the scope of this work, but a brief discussion on
exchange rate sourcing and security concerns can be found in
Section IV-C.
4) Protocol logic: The logic and state pertaining to the
issue and redeem protocols may but need not be contained
in a set of smart contracts. Alternative approaches to userdefined on-chain logic may allow these to be stored e.g. in
the runtime [28] or as precompiled modules [29].
C. Transfers and transactions
Along with Sapling’s Spend and Output transfers, the issuing chain supports Mint and Burn transfers. A Mint transfer is
a transfer creating value of the issued currency, i.e. increasing
the circulating supply. A Burn transfer takes the burnt amount
out of circulation. Transactions in the issuing chain may consist of any of the same components as a Sapling transaction,
and either a Mint or a Burn transfer. A transaction containing
a Mint transfer is a mint transaction, and one containing a
Burn transfer a burn transaction. Mint transfers contain a zkSNARK proving that a note has been sent to a vault on Zcash
and that the minted value corresponds to the locked value. In
Burn transfers, redeemers create a note they wish to receive
on Zcash and encrypt it to the vault, while publishing its
note commitment. The zk-SNARK in Burn transfers allows
redeemers to show that the value of said note matches the
burnt value. The transaction is only confirmed once the vault
provides an inclusion proof for this note. We refer the reader
to the original specification of this protocol [4, Section 5] for
concrete definitions of the aforementioned transfers and of zkSNARKs mentioned in this work.

D. Issuing and Redeeming
We define two sub-protocols, Issue and Redeem, adapted
from X CLAIM to address the challenges arising from integrating Zcash’s anonymity features.
The Issue sub-protocol allows issuers to lock ZEC with
vaults and mint wZEC on the issuing chain. In order to conceal
the transferred amount from the vaults, the issuer splits the
total into separate amounts beforehand and sends them to
n vaults such that no vault is able to deduce the total. We
present and analyse a possible splitting strategy to this end in
Section V-B. For each of these amounts, the issuer carries
out an Issue procedure, i.e. an instance of the Issue subprotocol. In short, the issuer proves that they have created
a note encrypted to a vault’s address and mints an equivalent
amount of wZEC in a mint transaction. The existence of this
note does not guarantee that it can be spent by the vault, hence
there is a challenge period during which vaults can void the
transaction by proving that the necessary values have not been
properly encrypted to them.
The Redeem sub-protocol allows a redeemer to receive ZEC
from vaults in exchange for burning wZEC on the issuing
chain. Redeemers shall employ the same splitting strategy as
issuers. For each individual amount, a redeemer submits a burn
transaction on the issuing chain which contains a commitment
to a note of equivalent value spendable by an address under
their control on Zcash. A vault then creates this note. Since the
vault must also learn the values from which the note is derived
in order to create it, there is a challenge period during which
it can challenge the request by showing that these were not
properly encrypted. If the values are correct, the vault must
create the note specified by the redeemer. Lastly, the vault
submits a proof showing that the note exists and the burn
transaction is finalised.
We present an overview of both sub-protocols. Diagrams
depicting these steps are shown in Fig. 1.
Issuing: Alice (issuer) locks funds with vault V on Zcash
to create units of wZEC on I.
0) Setup. V registers with the vault registry on I and locks
icol units of collateral, where it must hold that
icol ≥ vmax · (1 − f ) · σstd · xrcap

(III.1)

where vmax is the maximum amount of funds that can be
locked or burned per request, f is the Z CLAIM transaction
fee, and σstd is the standard collateralisation rate. These
values are implementation-defined constants. xrcap is the
exchange rate at the time the vault provides a proof
of capacity as explained next. Further, V must provide
a shielded payment address on Zcash to which issuers
will send their funds and submit a proof of capacity to
the vault registry, which is a zk-SNARK proving that
Eq. (III.1) holds. V must periodically resubmit proofs of
capacity in order to remain available for requests.
1) Commit. Alice makes a request to the issuing chain
to lock her funds with vault V with shielded payment
address (d, pkd )V . As part of this request, Alice locks

(a) Issue

(b) Redeem
Figure 1. Simplified diagrams of Z CLAIM protocols.

a small amount of i, iw , her warranty collateral. This
is a fixed amount large enough to compensate V for the
opportunity cost in case Alice does not follow through
with her request. Furthermore, it serves to prevent griefing attacks in which the system is spammed with lock
requests, becoming unavailable to legitimate users.
2) Lock permit. Subsequently, a lock permit is created on
I, granting permission to Alice to lock her funds with
V. This permit contains a cryptographic nonce nlock that
Alice must include in the transaction locking the funds.
If she fails to execute step 4 within some ∆mint , her
warranty collateral iw is transferred to V. The constant
∆mint will largely depend on how fast the relay system
considers blocks to have reached consensus. As a point
of reference, popular cryptocurrency exchanges require a
depth of 24 blocks or 30 minutes [30], [31].
3) Lock. Alice creates a shielded transaction on Zcash,
sending ZEClock to V. Alice uses nlock to derive the
randomness rcm, the so-called commitment trapdoor,
used to generate the commitment for the output note n
addressed to V in this transaction.
4) Create. Alice makes a request to issue wZECcreate to

a shielded address on I. To this end, Alice provides an
inclusion proof for a note with note commitment cmn ,
and further proves in zero knowledge that:
• she knows a note n with note commitment cmn ,
recipient (d, pkd )V and value ZEClock
• wZECcreate = ZEClock (1 − f ), where f is the fixed
fee rate the vault earns, and ZEClock ≤ vmax
• the trapdoor rcm was derived from nlock
The transaction Tmint issuing wZECcreate remains
pending until V confirms it. If V fails to do so within
some ∆confirmIssue , the same iw is deducted from V’s
collateral and transferred to Alice, and Tmint is confirmed. This delay may be quite small, as it only needs
to allow for V to see and respond to Tmint on I.
Furthermore, Alice publishes a note ciphertext C V of the
note n symmetrically encrypted to V.
5) Confirm/Challenge. V decrypts C V and verifies whether
the resulting note has note commitment cmn . If that is
the case, V confirms and the issuing process is complete.
On the other hand, if V finds that it cannot properly
decrypt C V , it may challenge the transaction by revealing
the shared secret used in the encryption while proving its
correctness in a zk-SNARK. It can then be verified on
chain that the encryption was erroneous, in which case
Tmint is discarded and Alice loses ZEClock and iw .
Redeeming: Dave (redeemer) burns wZEC on I and obtains
ZEC from vault V.
0) Setup. V is available to redeem, i.e. has not provided
a proof of insolvency to the vault registry since it last
participated in an Issue procedure. Vaults are available
for redeem requests by default. In order to be exempted
from them, they need to periodically provide proofs
of insolvency, showing that their ZEC obligations are
smaller than vmax . This simplified requirement ensures
users will always be able to redeem the existing supply.
1) Burn. Dave makes a request to burn funds wZECburn
on I by locking iw as warranty collateral and submitting
a transaction Tburn .
2) Redeem request. In this transaction, Dave specifies that he
would like to redeem ZEC from V in a note n with note
commitment cmn , and proves in zero knowledge that:
• he knows a note n with note commitment cmn and
value ZECrelease
• ZECrelease = wZECburn (1−f ), where f is the fixed
fee rate that the vault earns, and wZECburn ≤ vmax
In redeem requests, vaults earn fees implicitly through
their ZEC obligations decreasing by a larger amount than
the ZEC amount they release.
In order to transmit the note values to V, Dave publishes
the note ciphertext C V of the note n encrypted to V.
Tburn is not confirmed until V confirms the release
of ZECrelease . If V fails to do so or to challenge it
within some ∆confirmRedeem , iw is deducted from V’s
collateral and transferred to Dave, and Tburn is discarded.
∆confirmRedeem , like ∆mint , will largely depend on how

fast the relay system accepts blocks.
3) Release. V releases ZECrelease to Dave by creating a
note n with note commitment cmn .
4) Confirm/Challenge. V waits until the relay system signals
that consensus has been reached on the block in which n
was created and then submits an inclusion proof for this
note. Tburn is then confirmed.
However, if upon decryption of C V V finds that the
resulting plaintext does not correspond to a note with
note commitment cmn , it may challenge the transaction
as in step 5 of the Issue protocol, in which case Tburn is
voided and Dave’s warranty collateral is transferred to V.
In this case, V does not execute step 3.

Operations performed by vaults:
challengeIssue [AwaitIssueConfirm → IssueChallenged]
Z
allows a vault to prove that Tlock
has not been correctly
I
encrypted to it in (Tmint ).
• challengeRedeem
[AwaitRedeemConfirm
→
RedeemChallenged] allows a vault to prove that
Z
I
Trelease
has not been correctly encrypted to it in (Tburn
).
Z
• release
→ Trelease
[AwaitRedeemConfirm →
AwaitRedeemConfirm] releases funds to a redeemer.
• confirmIssue [AwaitIssueConfirm → IssueSuccess] alZ
lows a vault to confirm that it has received Tlock
, conI
firming the pending (Tmint ) transaction.
• confirmRedeem
[AwaitRedeemConfirm
→
RedeemSuccess] proves that the vault has released
Z
I
funds in Trelease
, confirming the pending (Tburn
)
transaction.
• submitPOB [VaultRegistered|IssueStart|NotIssuing →
NotIssuing] submits a proof of balance. Vaults may
perform this operation in order to prevent liquidation
instead of submitPOC if they don’t wish to become
available for new lock requests.
• submitPOC [VaultRegistered|IssueStart|NotIssuing →
IssueStart] submits a proof of capacity.
• submitPOI
[NotRedeeming|RedeemStart
→
NotRedeeming] submits a proof of insolvency.

•

E. Operations
We now define abstract operations for the two protocols
introduced in the previous section.
An operation always results in a transaction. On I, this
may either be a monetary transfer or a change in state. Each
operation leads to a specific state of the protocol, and to each
state there is an implicitly associated set of legal operations
for each party.
A
the transaction on blockchain A resulting
We denote by Top
from the successful execution of operation op. A may be either
Zcash, denoted by Z, or the issuing chain, denoted by I.
Certain transactions on I require confirmation from the other
Based on these operations, the Issue and Redeem protocols
party involved in the Issue or Redeem procedure and may be
voided if this confirmation is not provided within a certain are summarised in pseudocode in Algorithms 1 and 2, respectdelay. We denote a transaction that is pending confirmation as ively.
I
I
), and one that is voided as 
(Top
(T
op ).
An operation that results in transaction Top , can be perAlgorithm 1 Issue
formed in state StartingState and leads to state OutputState
A
Require: VAULT has enough collateral
is denoted by op → Top [StartingState → OutputState].
1: VAULT executes submitPOC
For simplicity, we omit non-monetary and warranty collateral
2: if ISSUER executes requestLock and receives a lock permit then
Z
transactions as well as slashing, all of which take place only
3:
ISSUER executes lock →Tlock
I
→(T
mint ) within ∆mint then
4:
if ISSUER executes mint
on I. All operations can only be performed by a specific actor.
5:
if VAULT executes challengeIssue within ∆confirmIssue
Operations performed by issuers:
then
I

• requestLock [IssueStart → AwaitingMint] requests per6:
→
Tmint
7:
else
mission to lock funds with a vault. The issuer locks iw
8:
VAULT may execute confirmIssue within ∆confirmIssue
as collateral.
Z
I
• lock → Tlock [AwaitingMint → AwaitingMint] locks
9:
→ Tmint
10:
end if
ZEC with a vault.
11:
end if
I
• mint → (Tmint ) [AwaitingMint → AwaitIssueConfirm]
12: end if
allows the issuer to mint a hidden amount of wZEC on
I upon confirmation.
Algorithm 2 Redeem
If the vault fails to perform confirmIssue within
Require: VAULT has not called submitPOI since last issuing
I
I
∆confirmIssue , Tmint
is automatically confirmed and iw
1: REDEEMER executes burn →(Tburn )
is deducted from the vault’s collateral.
2: if VAULT executes challengeRedeem within ∆confirmRedeem
then
Operations performed by redeemers:
I

3:
→
Tburn
I
• burn → (Tburn ) [RedeemStart → AwaitRedeemConfirm]
4: else
Z
5:
VAULT executes release →Trelease
requests a specific vault to release ZEC and burns an
6:
if VAULT executes confirmRedeem within ∆confirmRedeem
equivalent amount of wZEC upon confirmation. The
then
I
redeemer locks iw as collateral.
7:
→ Tburn
8:
else
If the vault fails to perform confirmRedeem within
I

9:
→
Tburn
I
∆confirmRedeem , Tburn
is voided and iw is deducted from
10:
end if
the vault’s collateral.
11: end if

IV. ATTACK VECTORS AND POINTS OF FAILURE
We discuss here a range of attacks and points of failure in
Z CLAIM and offer mitigation strategies. Where not specified
otherwise, the discussion on vulnerabilities presented in the
security analysis of X CLAIM [5, Section VII] also holds here.

Bitcoin-based blockchains (such as Zcash is) for mitigation
strategies [34], [37].
C. Exchange rate poisoning

Without a robust splitting strategy, vaults may guess the
users’ identity through the amounts in lock and release transactions in which they are involved.
In the simplest scenario, if a user locks an amount with
a vault which matches a recent transparent-to-shielded transaction, the vault may deduce the origin of the funds [32]
and infer the user’s identity from activity associated with the
transparent address.
The same attack is possible if a vault is able to deduce or
estimate the total from one or a small subset of the amounts
sent to it. The splitting strategy defined in Section V-B aims
to prevent this sort of attack. The privacy provided by this
strategy is analysed in the remainder of said section.

If the exchange rate oracle is manipulated to provide
an erroneous price feed, the protocol may fail to maintain
proper collateralisation of the issued assets. An artificially
high exchange rate would allow vaults to issue ZEC or unlock
collateral such that they become undercollateralised after the
attack. On the other hand, an artificially low exchange rate
may trigger mass liquidation and allow users to buy vaults’
collateral at an unfair price.
It is thus important to guarantee the reliability of the
exchange rate oracle. Blockchain oracles aim to solve this
exact problem [38], [39], aggregating exchange rates from
different sources, leveraging economic incentives to reinforce
their veracity and providing dispute mechanisms in case of
discrepancies. These systems are, without question, safer than
relying on a single source to provide an exchange rate, though
they may still fail under certain circumstances [40].

B. Chain relay poisoning

D. Replay attacks on inclusion proofs

Chain relay poisoning involves an adversary triggering a
chain reorganisation such that a previously accepted transaction is invalidated; in other words, bypassing the relay system’s
consensus validation mechanism.
Since Zcash has probabilistic finality, this is in theory
always possible. However, a common practice consists in
deeming only blocks at depth h ≥ k to have reached consensus, where k is a security parameter denoting the block
depth at which the likelihood of an adversary with computational power bounded by α ≤ 33% [33] triggering a chain
reorganisation becomes negligible. This threshold is usually
a low number due to the probability of a successful attack
decreasing exponentially with increasing depth. Nevertheless,
it must be noted that the dangerous assumption here is not the
threshold k but α. The costs required to reach this threshold
vary wildly for different cryptocurrencies and a more in-depth
exploration of the feasibility of such an attack on Zcash
is recommended in order to find sensible values for these
parameters.
Furthermore, a poisoning attack may be successful well
below this threshold α if the relay system is deprived of
recent block header data [5, Section VII-A]. This is a common
vulnerability to interoperability schemes and may involve
intricate attacks in which relayers are isolated from the rest of
their peers in the network and misled to accept the attacker’s
chain as the longest, in what is commonly known as an eclipse
attack [34]. Note that as long as there is one honest relayer
connected to the rest of the network, the cost of attacking the
relay system is the same as that of running a 51% attack, since
block headers are verified based on proof of work and not on
the number of relayers submitting them.
Such attacks along with mitigation strategies have been
discussed previously in the literature [34], [35], [36], [37], and
we refer the reader in particular to analyses on Bitcoin and

Z CLAIM prevents replay attacks on lock and release transaction inclusion proofs, in which a user reuses a past lock
transaction to mint wZEC or a vault reuses a release transaction to decrease their ZEC obligations, as follows.
The nonce npermit generated in lock permits must be used to
generate the note commitment trapdoor in lock transactions,
which is enforced in the zero knowledge proof in Mint
transfers. This ensures that every lock transaction is uniquely
associated with the corresponding Issue procedure. As for
release transactions, protection from replay attacks is implicit
since the note commitment is generated in advance by the
redeemer. A vault can only replay a release inclusion proof if
the redeemer purposefully chooses the same note values, most
notably the same note commitment trapdoor as in a previous
Burn transfer.

A. Inference attacks

E. Counterfeiting
We define counterfeiting as the issuing of wZEC which
is not backed by an equivalent amount of collateral. As
previously outlined, vaults must periodically provide proofs of
balance showing that their ZEC obligations are collateralised
above a certain ratio. If a vault fails to do so and the exchange
rate changes by a certain margin since their last statement,
partial liquidation of their collateral is triggered. This ensures
the collateralisation ratio never falls below a certain minimum.
Furthermore, proofs of capacity ensure that such a statement
will hold after a mint. See [4, Section 5.12] for more details
on balance statements.
Note that wZEC does not need to be fully backed by ZEC,
which is impossible to guarantee while maintaining the vaults’
transaction history private. A vault may very well reuse ZEC
it has received to issue more wZEC; but it will remain unable
to unlock its collateral until it has released ZEC to redeemers
or acquired and burnt wZEC itself.

F. Sudden devaluation

Let e = max{1, 2blog2 vtot c+1−k/2 }.
• Choose an integer i uniformly at random from
[0, ebvtot /ec].
• When e > 1, do not transfer vtot − ebvtot /ec tokens.
• Split the remaining ebvtot /ec tokens into ei and
e(bvtot /ec − i), then split each of those into powers of 2.
• If this gives less than k pieces, then pad with 0.
If the amount vtot is in [2m+1 , 2h − 1], then the splitting
procedure is as follows:
m
m−c
• Let d = bvtot /2 c − 1, c = b(k − d)/2c and e = 2
.
m
• Split the total amount into d pieces of size 2 .
• Do not transfer vtot − ebvtot /ec tokens.
• Choose an integer i uniformly at random from
[0, bvtot /ec − d2m /e] and split the remaining ebvtot /ec −
d2m tokens firstly into ie and ebvtot /ec − d2m − ie.
• Split these into powers of two and pad with 0s to form
k pieces.
Note that this never gives the user more than k pieces.
•

Given the historically high volatility in cryptocurrency markets [41], [42], the risk of sudden, extreme devaluation of
either one of Zcash or the issuing currency w.r.t. the other is
non-negligible. In case of a drop in the valuation of Zcash,
Z CLAIM would continue to operate normally. In the opposite
case, the consequences would be similar to those discussed
in Section IV-C and Z CLAIM would eventually no longer
function. The strategy proposed in X CLAIM [5, p. 3] can be
employed to mitigate the risk.
V. S PLITTING STRATEGY AND ANALYSIS OF INFERENCE
ATTACKS

In this section, we demonstrate that vaults cannot infer the
total value prior to splitting. We consider a simple threat model
that describes what a single vault can infer from each quantity
received. We assume the user has an amount vtot to transfer
which is split among k vaults, where k is a low power of
two. If any vault receives an amount v, the vault knows that
vtot ≥ v. If the user transfers an amount vtot , then at least one
vault will receive vtot /k and so they can infer that the total
amount must be at least vtot /k. This means that at the very
high values of vtot , anonymity suffers.
We remark here that transaction fees on Zcash are generally
very low3 , hence requiring a total of up to e.g. k = 16
transactions per transfer is a realistic solution. Nevertheless,
this also needs to be the case on the issuing chain.
A. A scale-independent prior
The amount received by each vault is used to assign a
probability to the total amount using Bayesian inference. This
relies on a prior distribution on the total amount a user
might wish to transfer. This amount may span many orders
of magnitude, but the scale must be kept private. We assume
that the total amount is an integer in the range [1, 2h − 1]. The
prior distribution is then sampled as T = 2N + A, where N is
chosen uniformly from the integers in [0, h], and A is chosen
uniformly from the integers in [0, 2N − 1].
B. Proposed splitting protocol
In our splitting protocol, each user splits their total amount
vtot into k pieces. We restrict the size of each piece to 0 or
powers of two. To attribute piece sizes, an obvious protocol
is to use the powers of two that correspond to the highest
1 bits in the binary representation of the total amount vtot .
However, this would give away information about the total,
since each piece would eliminate half the possible values. We
get around this only using pieces of sizes from 0 to 2m , where
m = h + 1 − log2 k. If vtot is large, many pieces must be of
size 2m , which unfortunately means there are less pieces to
use on bits.
If the total amount t to split is in [1, 2m −1] then the splitting
procedure is as follows:
3 The default is 0.00001 ZEC [43], worth around 0.00176 USD at the time
of writing.

C. Forward probabilities
Assuming the user has a total of vtot tokens, we now
consider the probability that a vault chosen at random from the
k vaults has a piece size of 2j , for some 0 ≤ j ≤ m. We write
X0 , X1 , . . . , Xm+1 to denote random variables indicating the
number of pieces of size 0, 1, . . . , 2m respectively. We write
T for the random variable of the total amount. The probability
that a randomly-chosen vault has a piece size of 2j−1 for some
1 ≤ j ≤ m + 1, given that the user had vtot in total, is then
E[Xj |T = vtot ]/k.
Lemma V.1 If i is selected uniformly at random from the
integers in [0, 2c + a] for some integer 0 ≤ a < 2c , and
Yj denotes the jth bit of i, then:
(i) For 0 ≤ j ≤ c, 1/4 ≤ Pr[Yj = 1] ≤ 3/4.
(ii) Pr[Yc+1 = 1] ≤ 1/2.
(iii) The expected
number of 1s in the binary expansion of
P
i, E[ j Yj ], is between c/4 and (3c + 2)/4.
The lemma follows from the fact that selecting i from
[0, 2c −1] means that each bit would be 1 with probability 1/2,
and selecting i from [0, 2c + a] means that i is in [0, 2c − 1]
with probability over 1/2.
It follows easily from the definition of the protocol and
Lemma V.1 that:
Lemma V.2
(i) For 1 ≤ j ≤ m − k/2, E[Xj |T = vtot ] ≤ 3/2
(ii) E[Xm |T = vtot ] ≤ bt/2mc
(iii) E[X0 |T = vtot ] ≤ k
The following lemma requires analysing a great many cases,
for which there is no space here.
Lemma V.3
(i) For 1 ≤ j ≤ m − k/2, E[Xj ] ≥ k/4h
2 k}
(ii) m − k/2 < j < m + 1, E[Xj ] ≥ max{m+1−j,log
2h
(iii) E[Xm+1 ] ≥ 3(k − 2 log2 k)/4h
(iv) E[X0 ] ≥ k/8

D. Inference step
We now assume that a vault has received an amount v,
an instance of a random variable V , and consider what
information we gain about T . It is evident that t ≥ v, so
many values of t can be ruled out. Nonetheless, here we show
that the probability of any particular value of t greater than
v is not substantially larger than the probability given by the
prior.
Theorem V.4 For any j, t with P r[T = t|V = 2j+1 ] > 0 and
either 1 ≤ j < m + 1 or t < 2m+1 , we have:
Pr[T = vtot |V = 2j+1 ] ≤
Pr[T = vtot ]

3h
min{k/2, max{m + 1 − j, log2 k}}

For V = 0, we have:
Pr[T = vtot |V = 0] ≤ 8 Pr[T = t]
For V = 2m , t ≥ 2m+1 :
Pr[T = vtot |V = 2m ] ≤ Pr[T = vtot ]

4hbt/2m c
3(k − 2 log2 k)

Proof By Bayes rule, for v ∈ 0, 1, . . . 2m :
Pr[T = t|V = v] =

Pr[V = v|T = vtot ] Pr[T = vtot ]
Pr[V = v]

=v|T =vtot ]
We are interested in upper bounding the ratio Pr[VPr[V
.
=v]
E[X |T =v ]

j
tot
This ratio is
for respective j, with Pr[V = v] =
E[Xj ]
E[Xj ]/k. We may now simply substitute the upper bounds on
E[Xj |T = vtot ] given by Lemma V.2, and the lower bounds
on E[Xj ] given by Lemma V.3, to obtain the upper bound on
the ratio on each case.

E. Analysis
Substantial anonymity is achieved if vtot is not close to its
maximum value. Conditioning on vtot > 2j+1 rules out n ≤ j,
h
and thus gives Pr[T = vtot |T > 2j+1 ] = Pr[T = vtot ] h−j
Because of the choice of splitting procedure, receiving a piece
of size 2j + 1 gives k/2 possibilities for n, where j + 1 ≤ n ≤
h
appears in the inequality
j + k/2. This is why a factor of k/2
for this range. However for j + k/2 ≥ n > m + 1, pieces
of size 2m would be required, leaving fewer bits to use for
splitting and fewer possible n which satisfy j > m − k/2.
Hence we note that for larger values of vtot , the anonymity is
worse. However, crucially, the number of possible values for
n never falls below log2 k.
VI. L IMITATIONS AND F UTURE W ORK
We have argued that Z CLAIM provides privacy in crosschain transfers, but many of the benefits of interoperability
remain unattainable if privacy is to be maintained. Once
on the issuing chain, it is likely that interacting with the
chain in any way other than through plain transactions would
require the user to first convert the wrapped shielded assets
to transparent assets. Private exchanges have been proposed

in the literature [44], but to the authors’ knowledge none
currently exists in the blockchain landscape.
There exist also a number of limitations inherent to the
current design of the protocol, such as the number of transactions required for one cross-chain transfer following the
splitting strategy. As pointed out in Section V-B, this in not a
problem on the Zcash side. However, it imposes a limitation
on which blockchains can realistically function as an issuing
chain, as transaction fees on some blockchains can be orders
of magnitudes higher than Zcash’s.
Furthermore, the protocol presents a bootstrapping problem,
in that it depends on a sufficiently large number of vaults with
enough liquidity in order to function properly, which in turn
depend on serving enough requests to be profitable.
The way issue and redeem availability is currently awarded,
i.e. via the vault proving that it has at least the equivalent
of vmax in free collateral or by it revealing that it holds no
ZEC obligations, respectively, is non-optimal and may reveal
information about the transacted amount. Other approaches
should be explored, such as issue and redeem requests being
assigned to vaults based on on-chain randomness, whereupon
the vault chooses whether to accept it or not. Additionally,
although the number of concurrent Issue or Redeem requests
being served by a vault is currently limited to one, we think
concurrent requests should be feasible with minor modifications. It may also prove beneficial to allow vaults to set
transaction fees themselves, allowing them to fend off network
congestion and at the same time incentivising competitiveness.
Furthermore, although the protocol as presented in this
paper assumes that the currency being wrapped is Zcash, it can
be adapted to any implementation of Sapling on another chain.
Such implementations currently exist e.g. on Tezos [45], [46]
and there are a number of adaptations of the Zerocash protocol
deployed in smart contracts, for instance on Ethereum [47] and
Quorum [48]. The changes required for compatibility would
mostly limit themselves to the relay system and note commitment verification, whereas the protocol logic is independent
of any specific implementation.
Z CLAIM is currently being adapted to the more recent
Orchard version of Zcash and is to be extended for usage with
multi-asset shielded pool extensions of the Zcash protocol.
VII. C ONCLUSION
We have shown that it is possible to maintain the privacypreserving qualities of the Sapling specification of Zcash in
cross-chain transfers. More generally speaking, we provide
a scheme for a decentralised cross-chain transfer protocol
that integrates with a privacy-oriented cryptocurrency. We
show that no single intermediary can infer the total amount
transferred through the bridge.
ACKNOWLEDGEMENTS
The authors would like to thank Petar Tsankov for supervising the master’s thesis which made this work possible,
Jeff Burdges for his assistance with cryptography, Alfonso
Cevallos for useful discussions related to the splitting strategy,
and Elizabeth Herbert for editorial support.

R EFERENCES
[1] S. Schulte, M. Sigwart, P. Frauenthaler, and M. Borkowski, “Towards
blockchain interoperability,” in International conference on business
process management. Springer, 2019, pp. 3–10.
[2] R. Belchior, A. Vasconcelos, S. Guerreiro, and M. Correia, “A survey
on blockchain interoperability: Past, present, and future trends,” ACM
Computing Surveys (CSUR), vol. 54, no. 8, pp. 1–41, 2021.
[3] R. Zhang, R. Xue, and L. Liu, “Security and privacy on blockchain,”
ACM Computing Surveys (CSUR), vol. 52, no. 3, pp. 1–34, 2019.
[4] A. Sanchez, “Confidential cross-blockchain exchanges: Designing
a privacy-preserving interoperability scheme,” Unpublished master’s
thesis, ETH Zürich, Dec. 2020.
[5] A. Zamyatin, D. Harz, J. Lind, P. Panayiotou, A. Gervais, and W. Knottenbelt, “XCLAIM: Trustless, interoperable, cryptocurrency-backed assets,” in 2019 IEEE Symposium on Security and Privacy (SP). IEEE,
Mar. 2019, pp. 193–210.
[6] D. Hopwood, S. Bowe, T. Hornby, and N. Wilcox, “Zcash
protocol specification,” Electric Coin Company, Technical specification,
Version 2020.1.15 [Overwinter+Sapling], 2020. [Online]. Available:
https://zips.z.cash/protocol/sapling.pdf
[7] A. Banerjee, M. Clear, and H. Tewari, “Demystifying the role of zkSNARKs in Zcash,” in 2020 IEEE Conference on Application, Information and Network Security (AINS). IEEE, 2020, pp. 12–19.
[8] Q. Feng, D. He, S. Zeadally, M. K. Khan, and N. Kumar, “A survey
on privacy protection in blockchain system,” Journal of Network and
Computer Applications, vol. 126, pp. 45–58, 2019.
[9] M. Herlihy, “Atomic cross-chain swaps,” in Proceedings of the 2018
ACM Symposium on Principles of Distributed Computing, ser. PODC
’18. New York, NY, USA: Association for Computing Machinery,
2018, pp. 245–254.
[10] [lightning-dev] an argument for single-asset lightning network. [Online].
Available: https://lists.linuxfoundation.org/pipermail/lightning-dev/2018
-December/001752.html
[11] N. Van Saberhagen, “Cryptonote v 2.0,” Monero white paper, 2013.
[Online]. Available: https://www.getmonero.org/ru/resources/researchlab/pubs/whitepaper annotated.pdf
[12] J. Gugger, “Bitcoin-monero cross-chain atomic swap,” Cryptology
ePrint Archive, Report 2020/1126, 2020. [Online]. Available: https:
//ia.cr/2020/1126
[13] CCS - Monero atomic swaps. [Online]. Available: https://ccs.getmoner
o.org/proposals/h4sh3d-atomic-swap-implementation.html
[14] noot/atomic-swap: ETH-XMR atomic swap prototype. [Online].
Available: https://github.com/noot/atomic-swap
[15] A. Zamyatin, M. Al-Bassam, D. Zindros, E. Kokoris-Kogias, P. MorenoSanchez, A. Kiayias, and W. J. Knottenbelt, “SoK: Communication
across distributed ledgers,” in Financial Cryptography and Data Security. Springer Berlin Heidelberg, 2021, pp. 3–36.
[16] Wrapped. [Online]. Available: https://www.wrapped.com/
[17] Home · renproject/ren wiki. [Online]. Available: https://github.com/ren
project/ren/wiki
[18] Zcash — Ren client docs. [Online]. Available: https://renproject.github.
io/ren-js-v3-docs/classes/ renproject chains bitcoin.Zcash.html
[19] Z. F. Team. Bringing privacy to Cosmos with Zcash. [Online].
Available: https://zfnd.org/bringing-privacy-to-cosmos-with-zcash/
[20] Github - ZcashFoundation/zcash-pegzone: A shielded pegzone bridging
Cosmos and Zcash. [Online]. Available: https://github.com/ZcashFoun
dation/zcash-pegzone
[21] J. Kwon and E. Buchman, “Cosmos: A network of distributed
ledgers,” Tendermint Inc., White paper. [Online]. Available: https:
//v1.cosmos.network/resources/whitepaper
[22] E. Ben-Sasson, A. Chiesa, C. Garman, M. Green, I. Miers, E. Tromer,
and M. Virza, “Zerocash: Decentralized anonymous payments from
Bitcoin,” in 2014 IEEE Symposium on Security and Privacy. IEEE,
May 2014, pp. 459–474.
[23] ——, “Zerocash: Decentralized anonymous payments from Bitcoin
(extended version),” Cryptology ePrint Archive: Report 2014/349, May
2014. [Online]. Available: https://eprint.iacr.org/2014/349
[24] S. Nakamoto, “Bitcoin: A peer-to-peer electronic cash system,” Bitcoin
white paper, 2008. [Online]. Available: https://bitcoin.org/bitcoin.pdf
[25] V. Buterin, “Chain interoperability,” R3, Tech. Rep., 2016. [Online].
Available: https://www.r3.com/wp-content/uploads/2017/06/chain inter
operability r3.pdf

[26] Simplified payment verification (SPV) – BitcoinWiki. [Online].
Available: https://en.bitcoinwiki.org/wiki/SPV
[27] A. Back, M. Corallo, L. Dashjr, M. Friedenbach, G. Maxwell,
A. Miller, A. Poelstra, J. Timón, and P. Wuille, “Enabling blockchain
innovations with pegged sidechains,” Tech. Rep., 2014. [Online].
Available: https://blockchainlab.com/pdf/sidechains.pdf
[28] J. Burdges, A. Cevallos, P. Czaban, R. Habermeier, S. Hosseini, F. Lama,
H. K. Alper, X. Luo, F. Shirazi, A. Stewart et al., “Overview of Polkadot
and its design considerations,” Web3 Foundation, Tech. Rep., May 2020.
[29] The DFINITY Team, “The internet computer for geeks,” Cryptology
ePrint Archive, Report 2022/087, 2022. [Online]. Available: https:
//ia.cr/2022/087
[30] Cryptocurrency deposit processing times – Kraken. [Online]. Available:
https://support.kraken.com/hc/en-us/articles/203325283-Cryptocurrenc
y-deposit-processing-times
[31] How long until my crypto deposit reaches my account? – Gemini.
[Online]. Available: https://support.gemini.com/hc/en-us/articles/20542
4836-How-long-until-my-digital-asset-deposit-reaches-my-account
[32] J. Quesnelle, “On the linkability of Zcash transactions,” Dec. 2017,
arXiv:1712.01210 [cs.CR].
[33] A. Gervais, G. O. Karame, K. Wüst, V. Glykantzis, H. Ritzdorf,
and S. Capkun, “On the security and performance of proof of work
blockchains,” in Proceedings of the 2016 ACM SIGSAC conference on
computer and communications security, 2016, pp. 3–16.
[34] E. Heilman, A. Kendler, A. Zohar, and S. Goldberg, “Eclipse attacks on
Bitcoin’s peer-to-peer network,” in 24th USENIX Security Symposium
(USENIX Security 15). Washington, D.C.: USENIX Association, Aug.
2015, pp. 129–144.
[35] K. Wüst and A. Gervais, “Ethereum eclipse attacks,” ETH Zurich, Tech.
Rep., 2016.
[36] G. Xu, B. Guo, C. Su, X. Zheng, K. Liang, D. Wong, and H. Wang, “Am
I eclipsed? A smart detector of eclipse attacks for Ethereum,” Computers
& Security, vol. 88, p. 101604, Sep. 2019.
[37] B. Alangot, D. Reijsbergen, S. Venugopalan, and P. Szalachowski, “Decentralized lightweight detection of eclipse attacks on Bitcoin clients,” in
2020 IEEE International Conference on Blockchain (Blockchain), 2020,
pp. 337–342.
[38] J. Peterson and J. Krug, “Augur: a decentralized, open-source platform
for prediction markets,” CoRR, vol. abs/1501.01042, 2015. [Online].
Available: http://arxiv.org/abs/1501.01042
[39] S. Ellis, A. Juels, and S. Nazarov, “Chainlink: A decentralized oracle
network,” SmartContract ChainLink Ltd., White paper, 2017. [Online].
Available: https://research.chain.link/whitepaper-v1.pdf
[40] S. K. Lo, X. Xu, M. Staples, and L. Yao, “Reliability analysis for
blockchain oracles,” Computers & Electrical Engineering, vol. 83, p.
106582, Feb. 2020.
[41] J. Fry and J. E.-T. Cheah, “Negative bubbles and shocks in cryptocurrency markets,” International Review of Financial Analysis, vol. 47, pp.
343–352, Feb. 2016.
[42] J. E.-T. Cheah and J. Fry, “Speculative bubbles in Bitcoin markets?
an empirical investigation into the fundamental value of Bitcoin,”
Economics Letters, vol. 130, pp. 32–36, Feb. 2015.
[43] Zcash feature UX checklist — Zcash documentation. [Online].
Available: https://zcash.readthedocs.io/en/latest/rtd pages/ux wallet c
hecklist.html#transactions
[44] M. B. da Gama, J. Cartlidge, A. Polychroniadou, N. P. Smart, and
Y. T. Alaoui, “Kicking-the-bucket: Fast privacy-preserving trading
using buckets,” Cryptology ePrint Archive, Report 2021/1549, 2021.
[Online]. Available: https://ia.cr/2021/1549
[45] L. Goodman, “Tezos: a self-amending crypto-ledger,” White paper,
2014. [Online]. Available: https://tezos.com/whitepaper.pdf
[46] Nomadic Labs - sapling integration in Tezos - tech preview. [Online].
Available: https://research-development.nomadic-labs.com/sapling-inte
gration-in-tezos-tech-preview.html
[47] A. Rondelet and M. Zajac, “ZETH: On integrating Zerocash on Ethereum,” Apr. 2019, arXiv:1904.00905 [cs.CR].
[48] ZSL · ConsenSys/quorum wiki · GitHub. [Online]. Available:
https://github.com/ConsenSys/quorum/wiki/ZSL

